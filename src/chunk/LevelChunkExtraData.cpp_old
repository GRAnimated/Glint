#include "addons/ImGui/include/hk/gfx/ImGuiConfig.h"
#include "chunk/LevelChunkExtraData.h"

#include "Minecraft.Nbt/CompoundTag.h"
#include "Minecraft.World/level/Level.h"
#include "Minecraft.World/level/chunk/storage/OldChunkStorage.h"

#include "hk/hook/InstrUtil.h"
#include "hk/hook/Trampoline.h"

std::unordered_map<LevelChunk*, LevelChunkExtraData> g_LevelChunkExtraData;

LevelChunkExtraData::LevelChunkExtraData() {
    allocate();
}

LevelChunkExtraData::LevelChunkExtraData(LevelChunkExtraData&& other) noexcept {
    addBlocksLower = other.addBlocksLower;
    addBlocksUpper = other.addBlocksUpper;
    other.addBlocksLower = {nullptr, 0};
    other.addBlocksUpper = {nullptr, 0};
}

LevelChunkExtraData& LevelChunkExtraData::operator=(LevelChunkExtraData&& other) noexcept {
    if (this != &other) {
        delete[] addBlocksLower.data;
        delete[] addBlocksUpper.data;

        addBlocksLower = other.addBlocksLower;
        addBlocksUpper = other.addBlocksUpper;
        other.addBlocksLower = {nullptr, 0};
        other.addBlocksUpper = {nullptr, 0};
    }
    return *this;
}

LevelChunkExtraData::~LevelChunkExtraData() {
    delete[] addBlocksLower.data;
    delete[] addBlocksUpper.data;
}

void LevelChunkExtraData::allocate() {
    if (!addBlocksLower.data) {
        addBlocksLower.length = 32768;
        addBlocksLower.data = new unsigned char[32768]();
    }
    if (!addBlocksUpper.data) {
        addBlocksUpper.length = 32768;
        addBlocksUpper.data = new unsigned char[32768]();
    }
}

bool LevelChunkExtraData::isValid() const {
    return addBlocksLower.data && addBlocksUpper.data && addBlocksLower.length == 32768
           && addBlocksUpper.length == 32768;
}

void CreateExtraDataForChunk(LevelChunk* chunk) {
    if (!chunk)
        return;
    if (g_LevelChunkExtraData.find(chunk) == g_LevelChunkExtraData.end()) {
        g_LevelChunkExtraData.emplace(chunk, LevelChunkExtraData{});
    }
}

void DeleteExtraDataForChunk(LevelChunk* chunk) {
    if (!chunk)
        return;
    g_LevelChunkExtraData.erase(chunk);
}

bool HasExtraData(LevelChunk* chunk) {
    if (!chunk)
        return false;
    return g_LevelChunkExtraData.find(chunk) != g_LevelChunkExtraData.end();
}

LevelChunkExtraData* GetExtraData(LevelChunk* chunk) {
    if (!chunk)
        return nullptr;
    auto it = g_LevelChunkExtraData.find(chunk);
    if (it != g_LevelChunkExtraData.end()) {
        return &it->second;
    }
    return nullptr;
}

unsigned char getExtraBlockBits(LevelChunkExtraData* extra, int x, int y, int z) {
    if (!extra || !extra->isValid())
        return 0;

    int idx = (y % 128) * 256 + (x << 4) + z;
    if (idx / 2 >= 32768)
        return 0;

    unsigned char val = (y >= 128) ? extra->addBlocksUpper[idx / 2] : extra->addBlocksLower[idx / 2];
    return (idx & 1) ? (val >> 4) & 0x0F : val & 0x0F;
}

void setExtraBlockBits(LevelChunkExtraData* extra, int x, int y, int z, unsigned char highBits) {
    if (!extra || !extra->isValid())
        return;

    int idx = (y % 128) * 256 + (x << 4) + z;
    if (idx / 2 >= 32768)
        return;

    unsigned char& ref = (y >= 128) ? extra->addBlocksUpper[idx / 2] : extra->addBlocksLower[idx / 2];

    if (idx & 1)
        ref = (ref & 0x0F) | (highBits << 4);
    else
        ref = (ref & 0xF0) | (highBits & 0x0F);
}

HkTrampoline<void, OldChunkStorage*, LevelChunk*, Level*, CompoundTag*> chunkStorageSave
    = hk::hook::trampoline(
        [](OldChunkStorage* chunkStorage, LevelChunk* chunk, Level* level, CompoundTag* tag) -> void {
            chunkStorageSave.orig(chunkStorage, chunk, level, tag);

            hk::gfx::imguiLog("Saving extra data for chunk at (%d, %d)\n", chunk->xPos, chunk->zPos);

            LevelChunkExtraData* extra = GetExtraData(chunk);
            if (extra) {
                tag->putByteArray(L"AddBlocksLower", arrayWithLength<u8>(extra->addBlocksLower.data,
                                                                         extra->addBlocksLower.length));
                tag->putByteArray(L"AddBlocksUpper", arrayWithLength<u8>(extra->addBlocksUpper.data,
                                                                         extra->addBlocksUpper.length));
            }
        });

HkTrampoline<void, OldChunkStorage*, Level*, CompoundTag*, LevelChunk*> chunkStorageLoad
    = hk::hook::trampoline(
        [](OldChunkStorage* chunkStorage, Level* level, CompoundTag* tag, LevelChunk* chunk) -> void {
            chunkStorageLoad.orig(chunkStorage, level, tag, chunk);

            hk::gfx::imguiLog("Loading extra data for chunk at (%d, %d)\n", chunk->xPos, chunk->zPos);

            LevelChunkExtraData* extra = GetExtraData(chunk);
            if (extra) {
                arrayWithLength<u8> lower = tag->getByteArray(L"AddBlocksLower");
                arrayWithLength<u8> upper = tag->getByteArray(L"AddBlocksUpper");

                if (lower.length == 32768)
                    memcpy(extra->addBlocksLower.data, lower.data, 32768);
                if (upper.length == 32768)
                    memcpy(extra->addBlocksUpper.data, upper.data, 32768);

                delete[] lower.data;
                delete[] upper.data;
            }
        });

HkTrampoline<void, OldChunkStorage*, LevelChunk*, Level*, DataOutputStream*> chunkStorageSave2
    = hk::hook::trampoline(
        [](OldChunkStorage* chunkStorage, LevelChunk* chunk, Level* level, DataOutputStream* out) -> void {
            chunkStorageSave2.orig(chunkStorage, chunk, level, out);

            hk::gfx::imguiLog("Saving extra data for chunk at (%d, %d)\n", chunk->xPos, chunk->zPos);

            LevelChunkExtraData* extra = GetExtraData(chunk);
            if (extra) {
                out->write(extra->addBlocksLower);
                out->write(extra->addBlocksUpper);
            }
        });

HkTrampoline<void, OldChunkStorage*, Level*, int, int, LevelChunk*> chunkStorageLoad2 = hk::hook::trampoline(
    [](OldChunkStorage* chunkStorage, Level* level, int x, int z, LevelChunk* chunk) -> void {
        chunkStorageLoad2.orig(chunkStorage, level, x, z, chunk);

        hk::gfx::imguiLog("Loading extra data for chunk at (%d, %d)\n", chunk->xPos, chunk->zPos);

        LevelChunkExtraData* extra = GetExtraData(chunk);
        if (extra) {
            extra->allocate();
            extra->addBlocksLower.length = 32768;
            extra->addBlocksUpper.length = 32768;
        }
    });

HkTrampoline<void, LevelChunk*, Level*, int, int> levelChunkCtor1
    = hk::hook::trampoline([](LevelChunk* chunk, Level* level, int x, int z) -> void {
          levelChunkCtor1.orig(chunk, level, x, z);

          if (chunk->xPos != 0 || chunk->zPos != 0)
              CreateExtraDataForChunk(chunk);
      });

HkTrampoline<void, LevelChunk*, Level*, ChunkPrimer*, int, int> levelChunkCtor2
    = hk::hook::trampoline([](LevelChunk* chunk, Level* level, ChunkPrimer* primer, int x, int z) -> void {
          levelChunkCtor2.orig(chunk, level, primer, x, z);

          CreateExtraDataForChunk(chunk);
      });

HkTrampoline<void, LevelChunk*, Level*, int, int, LevelChunk*> levelChunkCtor3
    = hk::hook::trampoline([](LevelChunk* chunk, Level* level, int x, int z, LevelChunk* other) -> void {
          levelChunkCtor3.orig(chunk, level, x, z, other);

          CreateExtraDataForChunk(chunk);
      });

HkTrampoline<void, LevelChunk*> levelChunkDtor = hk::hook::trampoline([](LevelChunk* chunk) -> void {
    DeleteExtraDataForChunk(chunk);
    levelChunkDtor.orig(chunk);
});

HkTrampoline<int, LevelChunk*, int, int, int> getBlockId
    = hk::hook::trampoline([](LevelChunk* chunk, int x, int y, int z) -> int {
          unsigned char highBits = 0;
          int id = getBlockId.orig(chunk, x, y, z);
          LevelChunkExtraData* extra = GetExtraData(chunk);
          if (extra)
              highBits = getExtraBlockBits(extra, x, y, z);

          return (highBits << 8) | id;
      });

class CompressedBlockStorage {
public:
    void set(int, int, int, int);
};

void setExtraBlockData(CompressedBlockStorage* orig, int x, int y, int z, int id) {
    LevelChunk* chunk;
    __asm volatile("mov %0, x19" : "=r"(chunk));  // Grab x19 (LevelChunk*)

    if (id > 255) {
        orig->set(x, y, z, id & 0xFF);

        if (chunk) {
            LevelChunkExtraData* extra = GetExtraData(chunk);
            if (extra) {
                setExtraBlockBits(extra, x, y, z, (id >> 8) & 0x0F);
            }
        }
    } else {
        orig->set(x, y, z, id);

        if (chunk) {
            LevelChunkExtraData* extra = GetExtraData(chunk);
            if (extra) {
                setExtraBlockBits(extra, x, y, z, 0);  // Clear high bits
            }
        }
    }
}

void LevelChunkExtraData::initHooks() {
    chunkStorageSave.installAtSym<"_ZN15OldChunkStorage4saveEP10LevelChunkP5LevelP11CompoundTag">();
    chunkStorageLoad.installAtSym<"_ZN15OldChunkStorage4loadEP5LevelP11CompoundTagP10LevelChunk">();
    chunkStorageSave2.installAtSym<"_ZN15OldChunkStorage4saveEP10LevelChunkP5LevelP16DataOutputStream">();
    chunkStorageLoad2.installAtSym<"_ZN15OldChunkStorage4loadEP5LeveliiP10LevelChunk">();

    levelChunkCtor1.installAtSym<"_ZN10LevelChunkC1EP5Levelii">();
    levelChunkCtor2.installAtSym<"_ZN10LevelChunkC1EP5LevelP11ChunkPrimerii">();
    levelChunkCtor3.installAtSym<"_ZN10LevelChunkC1EP5LeveliiPS_">();
    levelChunkDtor.installAtSym<"_ZN10LevelChunkD1Ev">();

    getBlockId.installAtSym<"_ZN10LevelChunk10getBlockIdEiii">();

    const hk::ro::RoModule* main = hk::ro::getMainModule();
    hk::hook::writeBranchLink(main, 0x209A78, setExtraBlockData);  // setBlock
    hk::hook::writeBranchLink(main, 0x209FF8, setExtraBlockData);  // setBlockAndData
}
